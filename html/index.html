{{define "indexPage"}}
<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>To Do App </title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" type="text/css" href="/static/style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" />

  <link rel="stylesheet" type="text/css" href="/static/style.css" />
  <style>
    @keyframes fadeSlide {
      from { opacity: 0; transform: translateY(8px); }
      to   { opacity: 1; transform: translateY(0); }
    }
    .animate-entry {
      animation: fadeSlide 0.35s ease-out;
    }
    .todo {
      display: grid;
      /* 3 columns: checkbox | stacked content | stacked right (due+actions) */
      grid-template-areas: "chk content right";
      grid-template-columns: auto 1fr auto;
      column-gap: 0.75rem;
      align-items: start;

      /* Simple list look */
      padding: 0.6rem 0.8rem; /* modest spacing for readability */
      border-bottom: 1px solid #e9ecef; /* divider between items */
      background: transparent;
      border-radius: 0;
      box-shadow: none;

      width: 100%;
      box-sizing: border-box;
    }
    .todo-checkbox { grid-area: chk; margin-right: 2px; transform: scale(1.2); cursor:pointer; }
    .todo-title { word-break: break-word; }
    .due-date { text-align: right; }
    .actions { display:flex; gap:0.4rem; align-self:flex-end; opacity:0; max-height:0; overflow:hidden; transition:max-height 180ms ease, opacity 180ms ease; pointer-events:none; }
    .actions button{ width:34px; height:34px; display:inline-flex; align-items:center; justify-content:center; }

    .todo:hover .actions { opacity:1; max-height:40px; pointer-events:auto; }
    .created-by { font-size:0.55rem; color:#777; display:block; line-height:1.2; word-break: break-word; }
    .content { grid-area: content; display:flex; flex-direction:column; gap:0.25rem; min-width:0; }
    .right   { grid-area: right;   display:flex; flex-direction:column; align-items:flex-end; justify-content:flex-start; gap:0.25rem; }
    .due-date{
      font-size:0.8rem;
      font-weight:600;
      white-space: nowrap;   /* keep on one line */
      margin: 0;             /* remove left offset */
      align-self: flex-end;  /* flush to the right of the column */
      text-align: right;
    }
    .due-overdue  { color:#dc3545; }  /* red */
    .due-today    { color:#ff5722; }  /* orange‚Äëred */
    .due-soon     { color:#ffc107; }  /* amber */
    .due-later    { color:#28a745; }  /* green */

   .completed { opacity: 0.85; }
   .completed .todo-title, .completed .due-date { text-decoration: line-through; opacity: 0.6; }
   .completed .created-by { opacity: 0.6; text-decoration: none; }
    .todo-checkbox {
      margin-right: 0.5rem;
      transform: scale(1.2);
      cursor: pointer;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 1rem;
      background: #f8f9fa;
      font-family: 'Poppins', sans-serif;
    }

    .top-bar .app-name {
      font-weight: 700;
    }

    .top-bar .user-name {
      font-weight: 400;
    }

    /* Header toolbar: left = view toggles, right = due filter */
    .toolbar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:0.75rem;
      margin-bottom:0.75rem;
      flex-wrap:wrap;
    }
    .due-filter label{ margin-right:0.4rem; font-size:0.9rem; color:#444; }
    .due-filter select{
      padding:0.35rem 0.6rem;
      border:1px solid #ced4da;
      border-radius:6px;
      font-family:'Poppins',sans-serif;
      background:#fff;
    }

    /* ‚Üì‚Üì‚Üì NEW DROPDOWN STYLES ‚Üì‚Üì‚Üì */
    .user-menu {
      position: relative;
    }

    .user-menu button {
      background: none;
      border: none;
      font: inherit;
      cursor: pointer;
      display: flex;
      align-items: center;
    }

    .dropdown {
      position: absolute;
      right: 0;
      top: 100%;
      background: #fff;
      border: 1px solid #ccc;
      box-shadow: 0 2px 4px rgba(0, 0, 0, .1);
      list-style: none;
      margin: 0;
      padding: 0;
      min-width: 120px;
      z-index: 1000;
    }

    .dropdown li a {
      display: block;
      padding: .5rem 1rem;
      color: #333;
      text-decoration: none;
    }

    .dropdown li a:hover {
      background: #f0f0f0;
    }

    .hidden {
      display: none;
    }

    /* ‚Üë‚Üë‚Üë END DROPDOWN STYLES ‚Üë‚Üë‚Üë */
    .view-toggle {
      margin-bottom: 0;
      text-align: left;
    }

    .toggle-btn {
      background: #e9ecef;
      border: 1px solid #ced4da;
      padding: 0.4rem 1rem;
      margin: 0 0.25rem;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
    }

    .toggle-btn.active {
      background: #007bff;
      color: #fff;
      border-color: #007bff;
    }

    /* Floating ‚ÄúAdd Task‚Äù panel */
    #new-todo {
      position: fixed;
      left: 50%;
      bottom: 24px;
      transform: translateX(-50%);
      display: flex;
      gap: 0.4rem;
      background: #ffffff;
      padding: 0.75rem 1rem;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.15);
      z-index: 100; /* keep above list */
      width: clamp(280px, 90%, 650px);
    }
    #new-todo input[type="text"],
    #new-todo input[type="date"],
    #new-todo select {
      flex: 1 1 auto;
    }
    #submit {
      white-space: nowrap;
    }

    .container {
      padding-bottom: 150px; /* space for floating panel */
      overflow: hidden;
    }
    /* Make the todos list scrollable rather than stretching the page */
    #todos {
      max-height: 70vh; /* adjust as needed */
      overflow-y: auto;
      display: block;         /* back to normal block flow */
      padding: 0.3rem;        /* keep some inset from container */
    }

    /* Optional: scrollbar aesthetics (WebKit/Blink) */
    #todos::-webkit-scrollbar {
      width: 6px;
    }
    #todos::-webkit-scrollbar-thumb {
      background-color: #bbb;
      border-radius: 3px;
    }
  </style>
</head>

<body>
  <header class="top-bar">
    <span class="app-name">todoing</span>
    <div class="user-menu">
      <button id="userBtn" class="user-name">
        {{ .Username }} &#9662;
      </button>
      <ul id="userDropdown" class="dropdown hidden">
        <li><a href="#" id="logoutLink">Logout</a></li>
      </ul>
    </div>
  </header>
  <div class="container">
    <div class="toolbar">
      <div class="view-toggle">
        <button id="btnAll" class="toggle-btn active">All Tasks</button>
        <button id="btnMine" class="toggle-btn">Created Tasks</button>
        <button id="btnAssigned" class="toggle-btn">Assigned To Me</button>
      </div>
      <div class="due-filter">
        <label for="dueSelect">Due:</label>
        <select id="dueSelect">
          <option value="all" selected>All</option>
          <option value="overdue">Overdue</option>
          <option value="today">Today</option>
          <option value="soon">Next 3 days</option>
          <option value="later">Later</option>
        </select>
      </div>
    </div>
    <div id="new-todo">
      <input id="titleInput" type="text" placeholder="Task title" />
      <input id="dueDateInput" type="date" />
      <select id="assignedToSelect">
        <option value="">-- assign to --</option>
      </select>
      <button id="submit">Add</button>
    </div>
    <div id="todos">

    </div>
  </div>
  <script>
    const localhostAddress = "http://localhost:9000/todo";
    let currentEndpoint = "/todo/";          // default: all tasks
    const loggedUsername = "{{ .Username }}";  // injected by template
    let currentUserId = "";  // will capture my user ID once users load
    const titleInput = document.getElementById("titleInput");
    const dueDateInput = document.getElementById("dueDateInput");
    const assignedToSelect = document.getElementById("assignedToSelect");
    let submitButton = document.getElementById("submit");
    let dueFilter = "all"; // all | overdue | today | soon | later

    const renderedIds = new Set();   // track which todos have been displayed

    async function loadUsers() {
      try {
        const res = await fetch("http://localhost:9000/auth/users", { credentials: "include" });
        const payload = await res.json();
        console.log("Users payload:", payload);   // üí° debug aid

        // Try a few common shapes the backend might return
        let users = null;
        if (Array.isArray(payload)) users = payload;
        else if (Array.isArray(payload.data)) users = payload.data;
        else if (Array.isArray(payload.users)) users = payload.users;
        else if (Array.isArray(payload.result)) users = payload.result;

        if (!users) {
          console.error("Unexpected users response shape:", payload);
          return;
        }

        users.forEach(u => {
          const opt = document.createElement("option");
          opt.value = u.id || u.ID || u._id || "";                     // tolerate various id keys
          opt.text = u.username || u.Username || u.email || "user";   // tolerate various name keys
          if (!currentUserId && opt.text === loggedUsername) {
            currentUserId = opt.value;
          }
          assignedToSelect.appendChild(opt);
        });
      } catch (err) {
        console.error("Could not load users:", err);
      }
    }

    async function getTodos() {
      try {
        const response = await fetch(`http://localhost:9000${currentEndpoint}`, {
          credentials: "include"
        });
        const responseData = await response.json();
        console.log("Fetched todos array:", responseData.data);
        return responseData.data || [];
      } catch (error) {
        console.error("Error:", error)
        return [];
      }
    }

    async function CreateTodo(data) {
      try {
        // üêû debug: show what we're sending
        console.log("POST payload:", JSON.stringify(data));

        const response = await fetch(`${localhostAddress}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(data),
        })
        const result = await response.json();
        console.log("success", result.message);
      } catch (error) {
        console.error("Error:", error);
        return [];
      }
    }

    async function DeleteTodo(TodoID) {
      console.log("Entering DeleteTodo with ID:", TodoID);
      try {
        const response = await fetch(`${localhostAddress}/${TodoID}`, {
          method: "DELETE",
        });
        console.log("Delete response status:", response.status);
        const rawDeleteText = await response.text();
        console.log("Raw delete response:", rawDeleteText);
        const result = JSON.parse(rawDeleteText);
        console.log("Success:", result.message)
      } catch (error) {
        console.error("error:", error)
      }
    }

    // Helper to update a todo item via API (PUT /todo/{id})
   async function UpdateTodo(id, payload) {
  try {
    const res = await fetch(`${localhostAddress}/${id}`, {
      method: "PUT",
      credentials: "include",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const contentType = res.headers.get("content-type") || "";

    if (!res.ok) {
      let msg = `HTTP ${res.status}`;

      try {
        if (contentType.includes("application/json")) {
          const data = await res.json();
          // Prefer the backend-provided error text
          msg = data.error || data.message || msg;
        } else {
          const text = await res.text();
          msg = text || msg;
        }
      } catch {
        // swallow parsing errors, keep fallback msg
      }

      alert(msg);            // e.g., "Title cannot be empty"
      console.error("Update failed:", msg);
      return;                // stop here on error
    }

    // Success
    const result = contentType.includes("application/json") ? await res.json() : null;
    console.log("Update result:", result?.message ?? "OK");
  } catch (err) {
    // Network or unexpected errors
    alert(err?.message ?? "Failed to update task");
    console.error("Failed to update todo:", err);
  }
}


    function deleteTaskButton() {
      const deleteTodoButtons = document.querySelectorAll(".delete")
      for (const deleteButton of deleteTodoButtons) {
        deleteButton.onclick = async function () {
          const todoID = deleteButton.getAttribute("data-id");
          console.log("Delete button clicked for ID:", todoID);
          await DeleteTodo(todoID);
          displayTodos();
        };
      }
    }

    async function addTask() {
      const dueMs = new Date(dueDateInput.value).getTime();   // epoch-ms

      const assignedId = assignedToSelect.value || currentUserId;

      const data = {
        title: titleInput.value.trim(),
        duedate: dueMs,
        assignedto: assignedId
      };

      await CreateTodo(data);
      displayTodos()
      // reset inputs
      titleInput.value = "";
      dueDateInput.value = "";
      assignedToSelect.value = "";
    }

    function matchesDue(todo, todayMs) {
      const rawDate = todo.DueDate || todo.duedate || todo.dueDate;
      const dueMs   = typeof rawDate === "number" ? rawDate : Date.parse(rawDate);
      if (Number.isNaN(dueMs)) {
        // tasks without a parsable due date are shown only when "All" is selected
        return dueFilter === "all";
      }
      const dayDiff = Math.floor((dueMs - todayMs) / 86400000);
      switch (dueFilter) {
        case "overdue": return dayDiff < 0;
        case "today":   return dayDiff === 0;
        case "soon":    return dayDiff > 0 && dayDiff <= 3;
        case "later":   return dayDiff > 3;
        case "all":
        default:         return true;
      }
    }

    function getDueMs(todo) {
      const rawDate = todo.DueDate || todo.duedate || todo.dueDate;
      const dueMs   = typeof rawDate === "number" ? rawDate : Date.parse(rawDate);
      return Number.isNaN(dueMs) ? Number.POSITIVE_INFINITY : dueMs;
    }

    function byProximityToToday(a, b, todayMs) {
      const da = Math.floor((getDueMs(a) - todayMs) / 86400000);
      const db = Math.floor((getDueMs(b) - todayMs) / 86400000);
      const aa = Math.abs(da), ab = Math.abs(db);
      if (aa !== ab) return aa - ab;   // nearer dates first
      return da - db;                  // tie-break: overdue (negative) first
    }

    async function displayTodos() {
      const rawList = await getTodos();
      // separate pending vs completed
      const pending = [];
      const doneArr = [];
      rawList.forEach(t => (t.completed ? doneArr : pending).push(t));

      const todayMs   = new Date().setHours(0,0,0,0);

      // In 'All Tasks' view, sort by proximity to today (nearest first),
      // while keeping completed items at the end.
      if (currentEndpoint === "/todo/") {
        pending.sort((a,b) => byProximityToToday(a,b,todayMs));
        doneArr.sort((a,b) => byProximityToToday(a,b,todayMs));
      }

      const todolist = [...pending, ...doneArr];   // completed at end
      const filtered  = todolist.filter(t => matchesDue(t, todayMs));

      const container = document.querySelector("#todos");
      container.innerHTML = "";

      if (filtered.length === 0) {
        container.innerHTML = `
          <div class="todo">
            <span>No tasks match the selected due filter.</span>
          </div>`;
        return;
      }

      filtered.forEach(todo => {
        const creator  = todo.CreatedBy || todo.createdBy || todo.createdby || "";
        const assignee = todo.assignedto || todo.assignedToName || "";
        const rawDate  = todo.DueDate   || todo.duedate    || todo.dueDate;
        const dueMs    = typeof rawDate === "number" ? rawDate : Date.parse(rawDate);
        const dueDate  = new Date(dueMs);
        const dayDiff  = Math.floor((dueMs - todayMs) / 86400000);

        let dueClass = "due-later";
        if (dayDiff < 0)        dueClass = "due-overdue";
        else if (dayDiff === 0) dueClass = "due-today";
        else if (dayDiff <= 3)  dueClass = "due-soon";

        const formatted = dueDate.toLocaleDateString(undefined, { year:"numeric", month:"short", day:"numeric" });
        const checked   = todo.completed ? "checked" : "";
        const doneClass = todo.completed ? "completed" : "";

        container.innerHTML += `
          <div class="todo ${doneClass}" data-id="${todo.id}">
            <input type="checkbox" class="todo-checkbox" ${checked}>
            <div class="content">
              <span class="todo-title">${todo.title}</span>
              <span class="created-by">${creator ? creator + " ‚Üí " + assignee : ""}</span>
            </div>
            <div class="right">
              <span class="due-date ${dueClass}" data-duems="${dueMs}" style="cursor:pointer;">Due on: ${formatted}</span>
              <div class="actions">
                <button class="edit"><i class="fas fa-edit"></i></button>
                <button data-id=${todo.id} class="delete"><i class="far fa-trash-alt"></i></button>
              </div>
            </div>
          </div>
        `;
      });

      /* --- animate newly added tasks --- */
      container.querySelectorAll(".todo").forEach(el => {
        const id = el.getAttribute("data-id");
        if (!renderedIds.has(id)) {
          renderedIds.add(id);
          el.classList.add("animate-entry");
          // remove class after animation so re‚Äëordering doesn't retrigger
          setTimeout(() => el.classList.remove("animate-entry"), 400);
        }
      });

      // wire up delete buttons
      deleteTaskButton();

      /* attach edit‚Äëbutton handlers */
      document.querySelectorAll(".edit").forEach(btn => {
        btn.onclick = async () => {
          const parent   = btn.closest(".todo");
          const todoId   = parent.getAttribute("data-id");
          const titleEl  = parent.querySelector(".todo-title");
          const oldTitle = titleEl.textContent.trim();

          const newTitle = prompt("Edit task title:", oldTitle);
          if (newTitle === null || newTitle.trim() === oldTitle) return; // cancel/no change

          const completed = parent.querySelector(".todo-checkbox").checked;
          await UpdateTodo(todoId, { title: newTitle.trim(), completed });
          displayTodos(); // refresh list
        };
      });

      // wire up checkbox change handlers
      document.querySelectorAll(".todo-checkbox").forEach(checkbox => {
        checkbox.onchange = async (e) => {
          const parent = checkbox.closest(".todo");
          const id = parent.getAttribute("data-id");
          const isDone = checkbox.checked;
          // optimistic UI
          if (isDone) parent.classList.add("completed");
          else        parent.classList.remove("completed");
          const title = parent.querySelector(".todo-title").textContent.trim();
          await UpdateTodo(id, { title: title, completed: isDone });
          displayTodos(); // refresh list
        };
      });

      /* attach due‚Äëdate click handlers */
      document.querySelectorAll(".due-date").forEach(el => {
        el.onclick = () => {
          const parent    = el.closest(".todo");
          const todoId    = parent.getAttribute("data-id");
          const currentMs = parseInt(el.getAttribute("data-duems"), 10);
          const isoToday  = new Date(currentMs).toISOString().slice(0, 10);

          // create a floating <input type="date">
          const picker = document.createElement("input");
          picker.type  = "date";
          picker.value = isoToday;

          const rect = el.getBoundingClientRect();
          picker.style.position = "absolute";
          picker.style.left     = rect.left + "px";
          picker.style.top      = (rect.bottom + window.scrollY) + "px";
          picker.style.zIndex   = 1000;

          document.body.appendChild(picker);
          picker.focus();

          picker.onchange = async () => {
            const newMs = new Date(picker.value).getTime();
            await UpdateTodo(todoId, { duedate: newMs });
            displayTodos();     // refresh list
            picker.blur();      // will trigger onblur handler to clean up
          };

          picker.onblur = () => {
            if (document.body.contains(picker)) {
              document.body.removeChild(picker);
            }
          };
        };
      });

    }
    loadUsers();
    displayTodos();

    /* ---------- user dropdown + logout ---------- */
    const userBtn = document.getElementById("userBtn");
    const userDropdown = document.getElementById("userDropdown");
    const logoutLink = document.getElementById("logoutLink");

    // ----- view toggle buttons -----
    const btnAll = document.getElementById("btnAll");
    const btnMine = document.getElementById("btnMine");
    const btnAssigned = document.getElementById("btnAssigned");

    function setActive(button) {
      btnAll.classList.remove("active");
      btnMine.classList.remove("active");
      btnAssigned.classList.remove("active");
      button.classList.add("active");
    }

    btnAll.addEventListener("click", () => {
      currentEndpoint = "/todo/";
      setActive(btnAll);
      displayTodos();
    });

    btnMine.addEventListener("click", () => {
      currentEndpoint = "/todo/createdbyme";
      setActive(btnMine);
      displayTodos();
    });

    btnAssigned.addEventListener("click", () => {
      currentEndpoint = "/todo/assignedtome";
      setActive(btnAssigned);
      displayTodos();
    });


    // ----- due-date filter dropdown -----
    const dueSelect = document.getElementById("dueSelect");
    if (dueSelect) {
      dueSelect.addEventListener("change", () => {
        dueFilter = dueSelect.value; // all | overdue | today | soon | later
        displayTodos();
      });
    }

    userBtn.addEventListener("click", () => {
      userDropdown.classList.toggle("hidden");
    });

    // Close dropdown when clicking outside
    document.addEventListener("click", (e) => {
      if (!userBtn.contains(e.target) && !userDropdown.contains(e.target)) {
        userDropdown.classList.add("hidden");
      }
    });

    logoutLink.addEventListener("click", async (e) => {
      e.preventDefault();
      await fetch("/auth/logout", { method: "POST", credentials: "include" });
      window.location.href = "/auth/login";
    });

    submitButton.addEventListener("click", () => addTask());
  </script>
</body>

</html>
{{end}}